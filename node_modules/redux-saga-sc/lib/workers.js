'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.handleEmit = handleEmit;
exports.handleRequest = handleRequest;

var _reduxSaga = require('redux-saga');

var _effects = require('redux-saga/effects');

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var _marked = [handleEmit, handleRequest].map(regeneratorRuntime.mark);

function handleEmit(socket, _ref) {
  var event = _ref.event;
  var _ref$autoReconnectOpt = _ref.autoReconnectOptions;
  var autoReconnectOptions = _ref$autoReconnectOpt === undefined ? socket.autoReconnectOptions || {} : _ref$autoReconnectOpt;
  var payload = _ref.payload;

  var _autoReconnectOptions, initialDelay, _autoReconnectOptions2, randomness, _autoReconnectOptions3, multiplier, _autoReconnectOptions4, maxDelay, timeout, exponent, initialTimeout;

  return regeneratorRuntime.wrap(function handleEmit$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _autoReconnectOptions = autoReconnectOptions.initialDelay;
          initialDelay = _autoReconnectOptions === undefined ? 10000 : _autoReconnectOptions;
          _autoReconnectOptions2 = autoReconnectOptions.randomness;
          randomness = _autoReconnectOptions2 === undefined ? 10000 : _autoReconnectOptions2;
          _autoReconnectOptions3 = autoReconnectOptions.multiplier;
          multiplier = _autoReconnectOptions3 === undefined ? 1.5 : _autoReconnectOptions3;
          _autoReconnectOptions4 = autoReconnectOptions.maxDelay;
          maxDelay = _autoReconnectOptions4 === undefined ? 60000 : _autoReconnectOptions4;
          timeout = void 0;
          exponent = 0;

        case 10:
          if (!true) {
            _context.next = 31;
            break;
          }

          _context.prev = 11;
          _context.next = 14;
          return (0, _effects.cps)([socket, socket.emit], event, payload);

        case 14:
          return _context.abrupt('return', _context.sent);

        case 17:
          _context.prev = 17;
          _context.t0 = _context['catch'](11);

          // @FIXME implement a rethrow if not TimeoutError instead of logging
          if ('console' in global) {
            console.error('catched error during handleEmit', _context.t0);
          }

          // prevent memory leaks in socket clients that do not reconnect when connection is lost

          if (!(socket.getState() === 'closed' && socket.pendingReconnect !== true)) {
            _context.next = 23;
            break;
          }

          // @TODO turn into a yield put(sym('SOCKET_CLOSED'))
          if (process.env.NODE_ENV !== 'production') {
            console.error('Socket got closed before the emit was acknowledged');
          }
          return _context.abrupt('return', false);

        case 23:
          initialTimeout = Math.round(initialDelay + (randomness || 0) * Math.random());


          timeout = Math.round(initialTimeout * Math.pow(multiplier, ++exponent));

          if (timeout > maxDelay) {
            timeout = maxDelay;
          }

          // @TODO turn into a yield put(sym('SOCKET_TIMEOUT'))
          if (process.env.NODE_ENV !== 'production') {
            console.error('Socket emit attempt #' + exponent + ' failed, will retry in ' + timeout + 'ms');
          }

          _context.next = 29;
          return (0, _effects.call)(_reduxSaga.delay, timeout);

        case 29:
          _context.next = 10;
          break;

        case 31:
        case 'end':
          return _context.stop();
      }
    }
  }, _marked[0], this, [[11, 17]]);
}

function handleRequest(socket, _ref2) {
  var _ref2$timeout = _ref2.timeout;
  var timeout = _ref2$timeout === undefined ? socket.ackTimeout : _ref2$timeout;

  var action = _objectWithoutProperties(_ref2, ['timeout']);

  var payload, _payload$payload, successType, failureType, _ref3, response, error;

  return regeneratorRuntime.wrap(function handleRequest$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          payload = action.payload;
          _payload$payload = payload.payload;
          successType = _payload$payload.successType;
          failureType = _payload$payload.failureType;
          _context2.next = 6;
          return (0, _effects.put)(payload);

        case 6:
          _context2.prev = 6;
          _context2.next = 9;
          return (0, _effects.call)(handleEmit, socket, action);

        case 9:
          _context2.next = 11;
          return (0, _effects.race)({
            response: (0, _effects.take)([successType, failureType]),
            timeout: (0, _effects.call)(_reduxSaga.delay, timeout)
          });

        case 11:
          _ref3 = _context2.sent;
          response = _ref3.response;

          if (response) {
            _context2.next = 17;
            break;
          }

          error = new Error('Socket request timed out waiting for a response');

          error.name = 'SocketTimeoutError';
          throw error;

        case 17:
          _context2.next = 23;
          break;

        case 19:
          _context2.prev = 19;
          _context2.t0 = _context2['catch'](6);
          _context2.next = 23;
          return (0, _effects.put)({ type: failureType, payload: { error: { name: _context2.t0.name, message: _context2.t0.message } } });

        case 23:
        case 'end':
          return _context2.stop();
      }
    }
  }, _marked[1], this, [[6, 19]]);
}